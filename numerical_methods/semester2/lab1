#include <iostream>
#include <fstream>
#include <cmath>
#include <iomanip>
#include <algorithm>
using namespace std;

const double epsilon = 1e-9;   // порог для деления в LU (pivot)
const double delta = 1e-10; // критерий сходимости по внедиагонали
const int MAX_ITER = 5000;

double** createMatrix(int n) {
    double** M = new double* [n];
    for (int i = 0; i < n; ++i) {
        M[i] = new double[n];
        for (int j = 0; j < n; ++j) M[i][j] = 0.0;
    }
    return M;
}

void deleteMatrix(double** M, int n) {
    if (!M) return;
    for (int i = 0; i < n; ++i) delete[] M[i];
    delete[] M;
}

void print_matrix(double** M, int n) {
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) cout << setw(6) << M[i][j] << "\t";
        cout << "\n";
    }
    cout << "\n";
}

double maxOffDiagonalAbs(double** M, int n) {
    double mx = 0.0;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            if (i != j) mx = max(mx, fabs(M[i][j]));
    return mx;
}

double normDiff(double** A, double** B, int n) {
    double mx = 0.0;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            mx = max(mx, fabs(A[i][j] - B[i][j]));
    return mx;
}

double** productMatrix(double** A, double** B, int n) {
    double** C = createMatrix(n);
    for (int i = 0; i < n; ++i)
        for (int k = 0; k < n; ++k) {
            double aik = A[i][k];
            if (aik == 0.0) continue;
            for (int j = 0; j < n; ++j)
                C[i][j] += aik * B[k][j];
        }
    return C;
}

struct LUresult {
    double** L;
    double** U;
    int n;
    bool ok;
};

LUresult LUdecomp_no_pivot(double** A, int n) {
    LUresult res;
    res.n = n;
    res.L = createMatrix(n);
    res.U = createMatrix(n);
    res.ok = true;

    for (int i = 0; i < n; ++i) {
        res.L[i][i] = 1.0;
        for (int j = 0; j < n; ++j) res.U[i][j] = A[i][j];
    }

    for (int k = 0; k < n; ++k) {
        double diag = res.U[k][k];
        if (fabs(diag) < epsilon) {
            res.ok = false;
            return res;
        }
        for (int i = k + 1; i < n; ++i) {
            res.L[i][k] = res.U[i][k] / diag;
            double mult = res.L[i][k];
            for (int j = k; j < n; ++j) {
                res.U[i][j] -= mult * res.U[k][j];
            }
            res.U[i][k] = 0.0;
        }
    }
    return res;
}

int main() {
    setlocale(LC_ALL, "Russian");

    ifstream f("file.txt");
    if (!f.is_open()) {
        cerr << "ошибка: не удалось открыть файл.\n";
        return 1;
    }

    int n;
    f >> n;
    if (n <= 0) {
        cerr << "ошибка: неверный размер матрицы\n";
        return 1;
    }

    double** A = createMatrix(n);
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            f >> A[i][j];
    f.close();

    cout << "матрица A:\n";
    print_matrix(A, n);

    double** A_cur = createMatrix(n);
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            A_cur[i][j] = A[i][j];

    int counter;
    for (counter = 1; counter <= MAX_ITER; ++counter) {
        LUresult lu = LUdecomp_no_pivot(A_cur, n);
        if (!lu.ok) {
            cerr << "метод неприменим\n";
            deleteMatrix(lu.L, n);
            deleteMatrix(lu.U, n);
            break;
        }

        double** A_new = productMatrix(lu.U, lu.L, n);

        double off = maxOffDiagonalAbs(A_new, n);
        double diff = normDiff(A_new, A_cur, n);

        deleteMatrix(lu.L, n);
        deleteMatrix(lu.U, n);

        // Проверка критерия сходимости: все внедиагонали малы
        if (off < delta) {
            deleteMatrix(A_cur, n);
            A_cur = A_new;
            break;
        }

        deleteMatrix(A_cur, n);
        A_cur = A_new;
    }

    if (counter == MAX_ITER) {
        cout << "Алгоритм не сошёлся за " << MAX_ITER << " итераций.\n";
    }

    cout << "собственные значения:\n";
    cout << fixed << setprecision(6);
    for (int i = 0; i < n; ++i) {
        cout << A_cur[i][i] << "\t";
    }
    cout << "\n\nИтоговая матрица A:\n";
    print_matrix(A_cur, n);

    // Чистим память
    deleteMatrix(A_cur, n);
    deleteMatrix(A, n);
    return 0;
}
