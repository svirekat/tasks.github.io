// 7. Сплайн-интерполяция

#include <iostream>
#include <fstream>
#include <string>
using namespace std;

const double epsilon = 1e-10;

// метод Прогонки:
double* progonka(double* a, double* b, double* c, double* d, int N) {
	double* result = new double[N + 2];

	double* alpha = new double[N + 1];
	double* beta = new double[N + 1];

	//прямой ход
	alpha[1] = -c[1] / b[1];
	beta[1] = d[1] / b[1];
	double denom;
	for (int k = 2; k <= N; k++) {
		denom = a[k] * alpha[k - 1] + b[k];
		if (abs(denom) <= epsilon) {
			cerr << "ошибка: нулевой знаменатель в методе прогонки!" << endl;
			return nullptr;
		}
		alpha[k] = -c[k] / denom;
		beta[k] = (d[k] - a[k] * beta[k - 1]) / denom;
	}

	//обратный ход
	result[N] = beta[N];
	for (int k = N - 1; k > 0; k--) {
		result[k] = alpha[k] * result[k + 1] + beta[k];
	}
	result[0] = 0;
	result[N + 1] = 0;

	delete[] alpha;
	delete[] beta;
	return result;
}

double cub(double t) {
	return t * t * t;
}

// форматирование числа: точка заменяется на запятую
string format(double z) {
	string s = to_string(z);
	size_t pos = s.find(".");
	if (pos != std::string::npos) // если запятая найдена
	{
		s.replace(pos, 1, ",");
	}
	return s;
}


int main() {
	setlocale(LC_ALL, "rus");
	double step = 0.01;       // шаг
	
	//чтение данных из файла:
	fstream file1("file_read2.txt");
	if (!file1.is_open()) {
		cerr << "ошибка: не удалось открыть файл." << endl;
		return 1;
	}
	int n;
	file1 >> n;
	double* x = new double[n];
	double* y = new double[n];
	for (int i = 0; i < n; i++) {
		file1 >> x[i];
		file1 >> y[i];
	}
	file1.close();

	double* h = new double[n];     // h - расстояние между соседними узлами
	for (int i = 1; i < n; i++) {
		h[i] = x[i] - x[i - 1];
		if (h[i] <= 0) {
			cerr << "ошибка: неупорядоченные или дублирующиеся точки x: h[" << i << "] = " << h[i] << endl;
			return 1;
		}
	}
	int nu = n - 2;   // nu - количество неизвестных q[i]
	double* a = new double[n+1];
	double* b = new double[n+1];
	double* c = new double[n+1];
	double* d = new double[n+1];
	
	// вычисление коэффициентов трёхдиагональной матрицы A
	// a * q[i-1] + b * q[i] + c * q[i+1] = d, где q[i] = S"(x_i) (вторая производная)
	for (int i = 1; i < n-1; i++)  
	{      
		if (i > 1) a[i] = h[i] / 6.0;
		b[i] = (h[i] + h[i + 1]) / 3.0;
		if (i < nu) c[i] = h[i + 1] / 6.0;
		d[i] = ( (y[i + 1] - y[i]) / h[i + 1] ) - ( (y[i] - y[i - 1]) / h[i] );
	}

	double* q = progonka(a, b, c, d, nu);     // нахождение всех q[i] с помощью метода прогонки
	if (!q) { 
		cerr << "ошибка при решении системы методом прогонки." << endl;
		delete[] a; delete[] b; delete[] c; delete[] d;
		delete[] x; delete[] y; delete[] h;
		return 1;
	}

	ofstream file2("file_write2.txt");
	if (!file2.is_open()) {
		cerr << "Ошибка: не удалось открыть файл." << endl;
		return 1;
	}


	int i = 1;
	double x_ = x[0], x_end = x[n - 1];
	while (x_ < x_end) {

		if (x_ >= x[i]) {  // определяется отрезок, которому принадлежит x_
			i++;
		}
		// находим значение сплайна в текущей точке x_
		double Spline = 
			q[i - 1] * cub(x[i] - x_) / (6 * h[i])
			+ q[i] * cub(x_ - x[i - 1]) / (6 * h[i])
			+ (y[i - 1] / h[i] - q[i - 1] * h[i] / 6) * (x[i] - x_)
			+ (y[i] / h[i] - q[i] * h[i] / 6) * (x_ - x[i - 1]);

		// запись результатов в файл:
		file2 << format(x_) << "\t" << format(Spline) << "\n";

		x_ += step; // Переходим к следующей точке
	}
	file2.close();

	cout << "программа успешно завершена!";

	delete[] q;
	delete[] x;
	delete[] y;
	delete[] h;
}
