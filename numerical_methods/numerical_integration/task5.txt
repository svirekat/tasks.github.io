#include <iostream>
#include <random>
using namespace std;

double koef(double a, double b, double omega_shtrih, double x1, double x2, double x3, double x4) {

	// cимметрические полиномы
	double s1 = x1 + x2 + x3 + x4;
	double s2 = x1 * x2 + x1 * x3 + x1 * x4 + x2 * x3 + x2 * x4 + x3 * x4;
	double s3 = x1 * x2 * x3 + x1 * x2 * x4 + x1 * x3 * x4 + x2 * x3 * x4;
	double s4 = x1 * x2 * x3 * x4;
	double integral =
		(pow(b, 5) - pow(a, 5)) / 5.0
		- s1 * (pow(b, 4) - pow(a, 4)) / 4.0
		+ s2 * (pow(b, 3) - pow(a, 3)) / 3.0
		- s3 * (b * b - a * a) / 2.0
		+ s4 * (b - a);

	return integral / omega_shtrih;
}

double f(double x) {
	return sin(x);
}

int main() {
	setlocale(LC_ALL, "Russian");
	string function = "sin(x)";
	int m;
	double A, B;
	cout << "введите границы отрезка:\n";
	cin >> A >> B;
	cout << "введите число отрезков в разбиении:\n";
	cin >> m;
	double step = (B - A) / (double)m;
	double a, b;

	std::random_device rd;
	std::mt19937 gen(rd());

	double answer = 0;

	for (double start = A; start + step <= B; start += step) {
		a = start;
		b = start + step;
		std::uniform_real_distribution<double> distrib(a, b);
		// задаём случайным образом 5 узлов интерполяции
		double x[5];
		x[0] = distrib(gen);
		x[1] = distrib(gen);
		x[2] = distrib(gen);
		x[3] = distrib(gen);
		x[4] = distrib(gen);

		double Sigma = 0;        // сумма, приближающая интеграл
		double S;

		for (int k = 0; k <= 4; k++) {
			S = 0;         // значение интерала на этом элементарном отрезке

			double omega_shtrih = 1;
			double x_j[4];
			int ind = 0;
			for (int j = 0; j <= 4; j++) {
				if (j != k) {
					omega_shtrih *= (x[k] - x[j]);
					x_j[ind] = x[j];
					ind++;
				}
			}
			
			double C_k = koef(a, b, omega_shtrih, x_j[0], x_j[1], x_j[2], x_j[3]);
			Sigma += C_k * f(x[k]);
		}
		answer += Sigma;
	}
	cout << "интеграл от функции " << function << " на отрезке [" << A << "; " << B << "] равен ~ " << answer << "\n";
}
